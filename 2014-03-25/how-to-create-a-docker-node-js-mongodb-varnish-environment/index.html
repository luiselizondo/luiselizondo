<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>How to create a Docker + Node.js + MongoDB + Varnish environment</title>

  <!-- CSS -->
  <link rel="stylesheet" href="/assets/css/main.css" type="text/css">
  <link rel="stylesheet" href="/assets/css/social-share-kit.css" type="text/css">

  <!-- Font -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">


  <link rel="alternate" type="application/rss+xml" title="RSS Feed for Luis Elizondo" href="/feed.xml" />
  <!-- Begin Jekyll SEO tag v2.0.0 -->
<title>How to create a Docker + Node.js + MongoDB + Varnish environment - Luis Elizondo</title>
<meta property="og:title" content="How to create a Docker + Node.js + MongoDB + Varnish environment" />
<meta name="description" content="I started learning Docker.io over the weekend and I must say that it&#39;s really cool, unfortunatelly, this is still a new project and you don&#39;t find lots of documentation and tutorials online. At first, I struggled a little to do what I&#39;m gonna show you, but here&#39;s the whole explanation so you don&#39;t have to. We&#39;re going to create a simple blog application written in Node.js running on a MongoDB database with a Varnish Load Balancer (covered on a different post) on top of the Node.js instances. We&#39;re going to use Docker and I strongly recommend to use Vagrant too, so you don&#39;t mess around too much with your host. In this tutorial, I won&#39;t cover installing Docker or the basics, since there&#39;s enough of that out there.First we need to create a new directory, in this directory I&#39;ll download 3 Git projects:A simple Blog application made with Node.js and Express.js MVCThe Docker Node.js imageThe Docker MongoDB imageAfter you download everything, you can take a look at the Dockerfiles, I&#39;ll explain a little what are they doing and how to run them.Node.js Docker imageFROM ubuntu:12.04MAINTAINER Luis Elizondo &quot;lelizondo@gmail.com&quot;RUN echo &quot;deb http://archive.ubuntu.com/ubuntu precise main universe&quot; &gt; /etc/apt/sources.listRUN apt-get updateRUN apt-get install -y python-software-properties curl gitRUN add-apt-repository -y ppa:chris-lea/node.jsRUN apt-get -qq updateRUN apt-get install -y nodejsRUN npm install -g expressjsmvc express nodemon bowerEXPOSE 3000ADD start.sh /start.shRUN chmod +x /start.shCMD [&quot;/start.sh&quot;]This one has a Dockerfile, a README, a run.sh file and a start.sh file. The start.sh file is intended to be used inside the container so you won’t really be using it but it’s important that you don’t modify it unless you know what you’re doing.The run.sh file is there so you can type ‘sh run.sh’ instead of the whole docker command which can get really long.The Dockerfile will install nodejs, use npm to install expressjsmvc, express, bower and nodemon; and then it will expose the port 3000 before adding the ‘start.sh’ file to the container and then run it.Now, I must explain something that I struggled with a little bit. When you’re using Dockerfiles (by now you should know what are they) you basically build your image so you can run containers and this container will run as specified. What this basically means is that you can create a container that will run a command as soon as it’s created or you can make this commands optional.This is a huge difference and it really depends on the service you’re configuring. When you use the ENTRYPOINT property in your Dockerfile basically you’re telling the image to run that command as soon as the container is created, so if you do something like this:Dockerfile:ENTRYPOINT [&quot;/start.sh&quot;]It means that the container will run the ‘start.sh’ file when it’s created. If you later want to do something like:$ docker run -it luis/nodejs bashTo access the container, it will not work, since the container will just ignore everything and will run ‘start.sh’So in order to have both, sometimes you’ll need to do CMD instead of ENTRYPOINT, this way, the container will run the command if you don’t pass any commands, but if you do pass any commands, it will run them.If I replace my Dockerfile withCMD [&quot;/start.sh&quot;]Then$ docker run -it luis/nodejs bashWill run bash, and:$ docker run -it luis/nodejsWill run start.shMongoDB Docker imageFROM ubuntu:12.04MAINTAINER Luis Elizondo, lelizondo@gmail.comRUN apt-get update################## BEGIN INSTALLATION####################### Install MongoDB Following the Instructions at MongoDB DocsRef: http://docs.mongodb.org/manual/tutorial/install-mongodb-on-ubuntu/Add the package verification keyRUN apt-key adv –keyserver hkp://keyserver.ubuntu.com:80 –recv 7F0CEB10Add MongoDB to the repository sources listRUN echo ‘deb http://downloads-distro.mongodb.org/repo/ubuntu-upstart dist 10gen’ | tee /etc/apt/sources.list.d/mongodb.listUpdate the repository sources list once moreRUN apt-get updateInstall MongoDB package (.deb)RUN apt-get install -y mongodb-10genCreate the default data directoryRUN mkdir -p /data/db##################### INSTALLATION END #####################Expose the default portEXPOSE 27017Default port to execute the entrypoint (MongoDB)CMD [”–port 27017”]Set default container commandENTRYPOINT /usr/bin/mongod&lt;/code&gt;This one is easier, it will expose two ports and then run the mongod service using ENTRYPOINT, so you cannot really access the container unless you rewrite the entrypoint.Build the imagesThe next step is to build your images, go to each directory containing a docker image and run:$ docker build -t myname/image-name .That command will build the image and tag it with a name, these are the commands I used:$ docker build -t luis/nodejs .$ docker build -t luis/mongodb .If I want to list all my images, I just do:$ docker imagesREPOSITORY          TAG                 IMAGE ID                      luis/nodejs         latest              3e9589892ef9               luis/mongodb        latest              79868a4506c7               &lt;/code&gt;How to link my docker containers?By now, you should be able to run your containers really easy and they should work, but they’re not linked, we need the Node container to access the MongoDB container. The first thing we need to do is to start a MongoDB container.$ docker run -itd -p 27017 --name mongodb luis/mongodbWhen we run this command, docker will create a new container with the image “luis/mongodb” and name that container as “mongodb”, it will also link the port 27017 to whatever port the container exposes, and it will also run this container as a daemon. This is very important since we want the container to start and keep running.Wait, what about files?Both MongoDB and your application need to read/write data on the HD, and you probably want to persist that data outside the container, which is disposable. The solution is to link volumes. First, let’s do this for MongoDB.By default, MongoDB, inside the container, will save the data in /data/db, and that’s fine, we actually created that directory inside the container on the Dockerfile. MongoDB will think is saving the data in /data/db but in reality, it will be saving the data outside the container in a directory we specify.Let’s create a new folder to save the data outside the container.$ sudo mkdir -p /var/mongodbAnd now, let’s fool MongoDB to save the data in /var/mongodb$ docker run -itd -p 27017 -v /var/mongodb:/data/db --name mongodb luis/mongodbWhat we’re doing differently is to link /var/mongodb (outside the container) to /data/db (inside the container).The same principle will apply to your application files.Linking containersNow we can go back to linking our containers. First, make sure you clone the application, in my case, I’m using a Node.js application that I created earlier, my files are at /home/luis/Docker/blog-exampleNow, to run my node.js container linked to MongoDB all I have to do is:$ docker run -itd -p 8000:3000 --name nodejs --link mongodb:mongodb -v /home/luis/Docker/blog-example:/var/www luis/nodejsLet’s explain what we’re doing with that command. First, we know my container will expose the port 3000, so we’re redirecting that port to the port 8000 (eventually we’ll have to modify this but for now we’re OK). Second, we set a name for the container. Third, we link the mongodb container, which basically allows the Node.js container to access the MongoDB container. Finally, we set the real path for /var/www, fooling our container for the real location of our files.My application is not workingThe application needs to install some stuff before running, so we’re going to need to install the dependencies before we run it.Let’s kill the container first:$ docker rm -f nodejsAnd now, let’s bash into it:$ docker run -it -p 8000:3000 --link mongodb:mongodb -v /home/luis/Docker/blog-example:/var/www luis/nodejs bashNotice that we’re not daemonizing the container so we can actually access it.If we list all the files in /var/www we’ll see that our application is there:$ ls -la /var/wwwdrwxr-xr-x  7 1000 1000 4096 Mar 25 05:09 .drwxr-xr-x 20 root root 4096 Mar 25 05:20 ..-rw-r--r--  1 1000 1000   34 Mar 25 05:09 .bowerrcdrwxr-xr-x  8 1000 1000 4096 Mar 25 05:09 .git-rw-r--r--  1 1000 1000   44 Mar 25 05:09 .gitignore-rw-r--r--  1 1000 1000 1377 Mar 25 05:09 app.js-rw-r--r--  1 1000 1000  260 Mar 25 05:09 bower.jsondrwxr-xr-x  4 1000 1000 4096 Mar 25 05:09 components-rw-r--r--  1 1000 1000  169 Mar 25 05:09 expressjsmvc.jsondrwxr-xr-x  2 1000 1000 4096 Mar 25 05:09 lib-rw-r--r--  1 1000 1000  327 Mar 25 05:09 package.jsondrwxr-xr-x  4 1000 1000 4096 Mar 25 05:09 public-rw-r--r--  1 1000 1000  824 Mar 25 05:09 start.jsdrwxr-xr-x  2 1000 1000 4096 Mar 25 05:09 viewsEnvironment variablesBefore I install everything, I want to show you a cool thing call environment variables. These are variables that are accessible by your system, do list them just do:$ envHOSTNAME=7921e0543e40MONGODB_NAME=/focused_engelbart/mongodbMONGODB_PORT_27017_TCP=tcp://172.17.0.2:27017TERM=xtermMONGODB_PORT=tcp://172.17.0.2:27017MONGODB_PORT_27017_TCP_PORT=27017PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binPWD=/MONGODB_PORT_27017_TCP_PROTO=tcpSHLVL=1HOME=/MONGODB_PORT_27017_TCP_ADDR=172.17.0.2_=/usr/bin/envAs you can see, I have several variables that reference MongoDB, this is because of the link we created. If we take a look at our application we can see that we’re using those variables.var address = process.env.MONGODB_PORT_27017_TCP_ADDR;var port = process.env.MONGODB_PORT_27017_TCP_PORT;mongoose.connect(&quot;mongodb://&quot; + address + &quot;:&quot; + port + &quot;/blog&quot;);Now let’s install all dependencies:$ cd /var/www$ npm install ; expressjsmvc installNow, let’s just exit our container:$ exitAnd let’s run it again:$ docker run -itd -p 8000:3000 --name nodejs --link mongodb:mongodb -v /home/luis/Docker/blog-example:/var/www luis/nodejsNow, let’s see what’s going on inside the container with:$ docker logs nodejsAnd finally, let’s open the browser and go to http://localhost:8000You should see out application up and running. You can add a new blog post going to http://localhost:8000/blogs/addWhat about Varnish?This blog post already got too long, so that’s going to have to wait until the next post." />
<meta property="og:description" content="I started learning Docker.io over the weekend and I must say that it&#39;s really cool, unfortunatelly, this is still a new project and you don&#39;t find lots of documentation and tutorials online. At first, I struggled a little to do what I&#39;m gonna show you, but here&#39;s the whole explanation so you don&#39;t have to. We&#39;re going to create a simple blog application written in Node.js running on a MongoDB database with a Varnish Load Balancer (covered on a different post) on top of the Node.js instances. We&#39;re going to use Docker and I strongly recommend to use Vagrant too, so you don&#39;t mess around too much with your host. In this tutorial, I won&#39;t cover installing Docker or the basics, since there&#39;s enough of that out there.First we need to create a new directory, in this directory I&#39;ll download 3 Git projects:A simple Blog application made with Node.js and Express.js MVCThe Docker Node.js imageThe Docker MongoDB imageAfter you download everything, you can take a look at the Dockerfiles, I&#39;ll explain a little what are they doing and how to run them.Node.js Docker imageFROM ubuntu:12.04MAINTAINER Luis Elizondo &quot;lelizondo@gmail.com&quot;RUN echo &quot;deb http://archive.ubuntu.com/ubuntu precise main universe&quot; &gt; /etc/apt/sources.listRUN apt-get updateRUN apt-get install -y python-software-properties curl gitRUN add-apt-repository -y ppa:chris-lea/node.jsRUN apt-get -qq updateRUN apt-get install -y nodejsRUN npm install -g expressjsmvc express nodemon bowerEXPOSE 3000ADD start.sh /start.shRUN chmod +x /start.shCMD [&quot;/start.sh&quot;]This one has a Dockerfile, a README, a run.sh file and a start.sh file. The start.sh file is intended to be used inside the container so you won’t really be using it but it’s important that you don’t modify it unless you know what you’re doing.The run.sh file is there so you can type ‘sh run.sh’ instead of the whole docker command which can get really long.The Dockerfile will install nodejs, use npm to install expressjsmvc, express, bower and nodemon; and then it will expose the port 3000 before adding the ‘start.sh’ file to the container and then run it.Now, I must explain something that I struggled with a little bit. When you’re using Dockerfiles (by now you should know what are they) you basically build your image so you can run containers and this container will run as specified. What this basically means is that you can create a container that will run a command as soon as it’s created or you can make this commands optional.This is a huge difference and it really depends on the service you’re configuring. When you use the ENTRYPOINT property in your Dockerfile basically you’re telling the image to run that command as soon as the container is created, so if you do something like this:Dockerfile:ENTRYPOINT [&quot;/start.sh&quot;]It means that the container will run the ‘start.sh’ file when it’s created. If you later want to do something like:$ docker run -it luis/nodejs bashTo access the container, it will not work, since the container will just ignore everything and will run ‘start.sh’So in order to have both, sometimes you’ll need to do CMD instead of ENTRYPOINT, this way, the container will run the command if you don’t pass any commands, but if you do pass any commands, it will run them.If I replace my Dockerfile withCMD [&quot;/start.sh&quot;]Then$ docker run -it luis/nodejs bashWill run bash, and:$ docker run -it luis/nodejsWill run start.shMongoDB Docker imageFROM ubuntu:12.04MAINTAINER Luis Elizondo, lelizondo@gmail.comRUN apt-get update################## BEGIN INSTALLATION####################### Install MongoDB Following the Instructions at MongoDB DocsRef: http://docs.mongodb.org/manual/tutorial/install-mongodb-on-ubuntu/Add the package verification keyRUN apt-key adv –keyserver hkp://keyserver.ubuntu.com:80 –recv 7F0CEB10Add MongoDB to the repository sources listRUN echo ‘deb http://downloads-distro.mongodb.org/repo/ubuntu-upstart dist 10gen’ | tee /etc/apt/sources.list.d/mongodb.listUpdate the repository sources list once moreRUN apt-get updateInstall MongoDB package (.deb)RUN apt-get install -y mongodb-10genCreate the default data directoryRUN mkdir -p /data/db##################### INSTALLATION END #####################Expose the default portEXPOSE 27017Default port to execute the entrypoint (MongoDB)CMD [”–port 27017”]Set default container commandENTRYPOINT /usr/bin/mongod&lt;/code&gt;This one is easier, it will expose two ports and then run the mongod service using ENTRYPOINT, so you cannot really access the container unless you rewrite the entrypoint.Build the imagesThe next step is to build your images, go to each directory containing a docker image and run:$ docker build -t myname/image-name .That command will build the image and tag it with a name, these are the commands I used:$ docker build -t luis/nodejs .$ docker build -t luis/mongodb .If I want to list all my images, I just do:$ docker imagesREPOSITORY          TAG                 IMAGE ID                      luis/nodejs         latest              3e9589892ef9               luis/mongodb        latest              79868a4506c7               &lt;/code&gt;How to link my docker containers?By now, you should be able to run your containers really easy and they should work, but they’re not linked, we need the Node container to access the MongoDB container. The first thing we need to do is to start a MongoDB container.$ docker run -itd -p 27017 --name mongodb luis/mongodbWhen we run this command, docker will create a new container with the image “luis/mongodb” and name that container as “mongodb”, it will also link the port 27017 to whatever port the container exposes, and it will also run this container as a daemon. This is very important since we want the container to start and keep running.Wait, what about files?Both MongoDB and your application need to read/write data on the HD, and you probably want to persist that data outside the container, which is disposable. The solution is to link volumes. First, let’s do this for MongoDB.By default, MongoDB, inside the container, will save the data in /data/db, and that’s fine, we actually created that directory inside the container on the Dockerfile. MongoDB will think is saving the data in /data/db but in reality, it will be saving the data outside the container in a directory we specify.Let’s create a new folder to save the data outside the container.$ sudo mkdir -p /var/mongodbAnd now, let’s fool MongoDB to save the data in /var/mongodb$ docker run -itd -p 27017 -v /var/mongodb:/data/db --name mongodb luis/mongodbWhat we’re doing differently is to link /var/mongodb (outside the container) to /data/db (inside the container).The same principle will apply to your application files.Linking containersNow we can go back to linking our containers. First, make sure you clone the application, in my case, I’m using a Node.js application that I created earlier, my files are at /home/luis/Docker/blog-exampleNow, to run my node.js container linked to MongoDB all I have to do is:$ docker run -itd -p 8000:3000 --name nodejs --link mongodb:mongodb -v /home/luis/Docker/blog-example:/var/www luis/nodejsLet’s explain what we’re doing with that command. First, we know my container will expose the port 3000, so we’re redirecting that port to the port 8000 (eventually we’ll have to modify this but for now we’re OK). Second, we set a name for the container. Third, we link the mongodb container, which basically allows the Node.js container to access the MongoDB container. Finally, we set the real path for /var/www, fooling our container for the real location of our files.My application is not workingThe application needs to install some stuff before running, so we’re going to need to install the dependencies before we run it.Let’s kill the container first:$ docker rm -f nodejsAnd now, let’s bash into it:$ docker run -it -p 8000:3000 --link mongodb:mongodb -v /home/luis/Docker/blog-example:/var/www luis/nodejs bashNotice that we’re not daemonizing the container so we can actually access it.If we list all the files in /var/www we’ll see that our application is there:$ ls -la /var/wwwdrwxr-xr-x  7 1000 1000 4096 Mar 25 05:09 .drwxr-xr-x 20 root root 4096 Mar 25 05:20 ..-rw-r--r--  1 1000 1000   34 Mar 25 05:09 .bowerrcdrwxr-xr-x  8 1000 1000 4096 Mar 25 05:09 .git-rw-r--r--  1 1000 1000   44 Mar 25 05:09 .gitignore-rw-r--r--  1 1000 1000 1377 Mar 25 05:09 app.js-rw-r--r--  1 1000 1000  260 Mar 25 05:09 bower.jsondrwxr-xr-x  4 1000 1000 4096 Mar 25 05:09 components-rw-r--r--  1 1000 1000  169 Mar 25 05:09 expressjsmvc.jsondrwxr-xr-x  2 1000 1000 4096 Mar 25 05:09 lib-rw-r--r--  1 1000 1000  327 Mar 25 05:09 package.jsondrwxr-xr-x  4 1000 1000 4096 Mar 25 05:09 public-rw-r--r--  1 1000 1000  824 Mar 25 05:09 start.jsdrwxr-xr-x  2 1000 1000 4096 Mar 25 05:09 viewsEnvironment variablesBefore I install everything, I want to show you a cool thing call environment variables. These are variables that are accessible by your system, do list them just do:$ envHOSTNAME=7921e0543e40MONGODB_NAME=/focused_engelbart/mongodbMONGODB_PORT_27017_TCP=tcp://172.17.0.2:27017TERM=xtermMONGODB_PORT=tcp://172.17.0.2:27017MONGODB_PORT_27017_TCP_PORT=27017PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binPWD=/MONGODB_PORT_27017_TCP_PROTO=tcpSHLVL=1HOME=/MONGODB_PORT_27017_TCP_ADDR=172.17.0.2_=/usr/bin/envAs you can see, I have several variables that reference MongoDB, this is because of the link we created. If we take a look at our application we can see that we’re using those variables.var address = process.env.MONGODB_PORT_27017_TCP_ADDR;var port = process.env.MONGODB_PORT_27017_TCP_PORT;mongoose.connect(&quot;mongodb://&quot; + address + &quot;:&quot; + port + &quot;/blog&quot;);Now let’s install all dependencies:$ cd /var/www$ npm install ; expressjsmvc installNow, let’s just exit our container:$ exitAnd let’s run it again:$ docker run -itd -p 8000:3000 --name nodejs --link mongodb:mongodb -v /home/luis/Docker/blog-example:/var/www luis/nodejsNow, let’s see what’s going on inside the container with:$ docker logs nodejsAnd finally, let’s open the browser and go to http://localhost:8000You should see out application up and running. You can add a new blog post going to http://localhost:8000/blogs/addWhat about Varnish?This blog post already got too long, so that’s going to have to wait until the next post." />
<link rel="canonical" href="http://localhost:4000/2014-03-25/how-to-create-a-docker-node-js-mongodb-varnish-environment/" />
<meta property="og:url" content="http://localhost:4000/2014-03-25/how-to-create-a-docker-node-js-mongodb-varnish-environment/" />
<meta property="og:site_name" content="Luis Elizondo" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2014-03-25T00:22:48+09:00" />
<script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "headline": "How to create a Docker + Node.js + MongoDB + Varnish environment",
    "datePublished": "2014-03-25T00:22:48+09:00",
    "description": "I started learning Docker.io over the weekend and I must say that it&#39;s really cool, unfortunatelly, this is still a new project and you don&#39;t find lots of documentation and tutorials online. At first, I struggled a little to do what I&#39;m gonna show you, but here&#39;s the whole explanation so you don&#39;t have to. We&#39;re going to create a simple blog application written in Node.js running on a MongoDB database with a Varnish Load Balancer (covered on a different post) on top of the Node.js instances. We&#39;re going to use Docker and I strongly recommend to use Vagrant too, so you don&#39;t mess around too much with your host. In this tutorial, I won&#39;t cover installing Docker or the basics, since there&#39;s enough of that out there.First we need to create a new directory, in this directory I&#39;ll download 3 Git projects:A simple Blog application made with Node.js and Express.js MVCThe Docker Node.js imageThe Docker MongoDB imageAfter you download everything, you can take a look at the Dockerfiles, I&#39;ll explain a little what are they doing and how to run them.Node.js Docker imageFROM ubuntu:12.04MAINTAINER Luis Elizondo &quot;lelizondo@gmail.com&quot;RUN echo &quot;deb http://archive.ubuntu.com/ubuntu precise main universe&quot; &gt; /etc/apt/sources.listRUN apt-get updateRUN apt-get install -y python-software-properties curl gitRUN add-apt-repository -y ppa:chris-lea/node.jsRUN apt-get -qq updateRUN apt-get install -y nodejsRUN npm install -g expressjsmvc express nodemon bowerEXPOSE 3000ADD start.sh /start.shRUN chmod +x /start.shCMD [&quot;/start.sh&quot;]This one has a Dockerfile, a README, a run.sh file and a start.sh file. The start.sh file is intended to be used inside the container so you won’t really be using it but it’s important that you don’t modify it unless you know what you’re doing.The run.sh file is there so you can type ‘sh run.sh’ instead of the whole docker command which can get really long.The Dockerfile will install nodejs, use npm to install expressjsmvc, express, bower and nodemon; and then it will expose the port 3000 before adding the ‘start.sh’ file to the container and then run it.Now, I must explain something that I struggled with a little bit. When you’re using Dockerfiles (by now you should know what are they) you basically build your image so you can run containers and this container will run as specified. What this basically means is that you can create a container that will run a command as soon as it’s created or you can make this commands optional.This is a huge difference and it really depends on the service you’re configuring. When you use the ENTRYPOINT property in your Dockerfile basically you’re telling the image to run that command as soon as the container is created, so if you do something like this:Dockerfile:ENTRYPOINT [&quot;/start.sh&quot;]It means that the container will run the ‘start.sh’ file when it’s created. If you later want to do something like:$ docker run -it luis/nodejs bashTo access the container, it will not work, since the container will just ignore everything and will run ‘start.sh’So in order to have both, sometimes you’ll need to do CMD instead of ENTRYPOINT, this way, the container will run the command if you don’t pass any commands, but if you do pass any commands, it will run them.If I replace my Dockerfile withCMD [&quot;/start.sh&quot;]Then$ docker run -it luis/nodejs bashWill run bash, and:$ docker run -it luis/nodejsWill run start.shMongoDB Docker imageFROM ubuntu:12.04MAINTAINER Luis Elizondo, lelizondo@gmail.comRUN apt-get update################## BEGIN INSTALLATION####################### Install MongoDB Following the Instructions at MongoDB DocsRef: http://docs.mongodb.org/manual/tutorial/install-mongodb-on-ubuntu/Add the package verification keyRUN apt-key adv –keyserver hkp://keyserver.ubuntu.com:80 –recv 7F0CEB10Add MongoDB to the repository sources listRUN echo ‘deb http://downloads-distro.mongodb.org/repo/ubuntu-upstart dist 10gen’ | tee /etc/apt/sources.list.d/mongodb.listUpdate the repository sources list once moreRUN apt-get updateInstall MongoDB package (.deb)RUN apt-get install -y mongodb-10genCreate the default data directoryRUN mkdir -p /data/db##################### INSTALLATION END #####################Expose the default portEXPOSE 27017Default port to execute the entrypoint (MongoDB)CMD [”–port 27017”]Set default container commandENTRYPOINT /usr/bin/mongod&lt;/code&gt;This one is easier, it will expose two ports and then run the mongod service using ENTRYPOINT, so you cannot really access the container unless you rewrite the entrypoint.Build the imagesThe next step is to build your images, go to each directory containing a docker image and run:$ docker build -t myname/image-name .That command will build the image and tag it with a name, these are the commands I used:$ docker build -t luis/nodejs .$ docker build -t luis/mongodb .If I want to list all my images, I just do:$ docker imagesREPOSITORY          TAG                 IMAGE ID                      luis/nodejs         latest              3e9589892ef9               luis/mongodb        latest              79868a4506c7               &lt;/code&gt;How to link my docker containers?By now, you should be able to run your containers really easy and they should work, but they’re not linked, we need the Node container to access the MongoDB container. The first thing we need to do is to start a MongoDB container.$ docker run -itd -p 27017 --name mongodb luis/mongodbWhen we run this command, docker will create a new container with the image “luis/mongodb” and name that container as “mongodb”, it will also link the port 27017 to whatever port the container exposes, and it will also run this container as a daemon. This is very important since we want the container to start and keep running.Wait, what about files?Both MongoDB and your application need to read/write data on the HD, and you probably want to persist that data outside the container, which is disposable. The solution is to link volumes. First, let’s do this for MongoDB.By default, MongoDB, inside the container, will save the data in /data/db, and that’s fine, we actually created that directory inside the container on the Dockerfile. MongoDB will think is saving the data in /data/db but in reality, it will be saving the data outside the container in a directory we specify.Let’s create a new folder to save the data outside the container.$ sudo mkdir -p /var/mongodbAnd now, let’s fool MongoDB to save the data in /var/mongodb$ docker run -itd -p 27017 -v /var/mongodb:/data/db --name mongodb luis/mongodbWhat we’re doing differently is to link /var/mongodb (outside the container) to /data/db (inside the container).The same principle will apply to your application files.Linking containersNow we can go back to linking our containers. First, make sure you clone the application, in my case, I’m using a Node.js application that I created earlier, my files are at /home/luis/Docker/blog-exampleNow, to run my node.js container linked to MongoDB all I have to do is:$ docker run -itd -p 8000:3000 --name nodejs --link mongodb:mongodb -v /home/luis/Docker/blog-example:/var/www luis/nodejsLet’s explain what we’re doing with that command. First, we know my container will expose the port 3000, so we’re redirecting that port to the port 8000 (eventually we’ll have to modify this but for now we’re OK). Second, we set a name for the container. Third, we link the mongodb container, which basically allows the Node.js container to access the MongoDB container. Finally, we set the real path for /var/www, fooling our container for the real location of our files.My application is not workingThe application needs to install some stuff before running, so we’re going to need to install the dependencies before we run it.Let’s kill the container first:$ docker rm -f nodejsAnd now, let’s bash into it:$ docker run -it -p 8000:3000 --link mongodb:mongodb -v /home/luis/Docker/blog-example:/var/www luis/nodejs bashNotice that we’re not daemonizing the container so we can actually access it.If we list all the files in /var/www we’ll see that our application is there:$ ls -la /var/wwwdrwxr-xr-x  7 1000 1000 4096 Mar 25 05:09 .drwxr-xr-x 20 root root 4096 Mar 25 05:20 ..-rw-r--r--  1 1000 1000   34 Mar 25 05:09 .bowerrcdrwxr-xr-x  8 1000 1000 4096 Mar 25 05:09 .git-rw-r--r--  1 1000 1000   44 Mar 25 05:09 .gitignore-rw-r--r--  1 1000 1000 1377 Mar 25 05:09 app.js-rw-r--r--  1 1000 1000  260 Mar 25 05:09 bower.jsondrwxr-xr-x  4 1000 1000 4096 Mar 25 05:09 components-rw-r--r--  1 1000 1000  169 Mar 25 05:09 expressjsmvc.jsondrwxr-xr-x  2 1000 1000 4096 Mar 25 05:09 lib-rw-r--r--  1 1000 1000  327 Mar 25 05:09 package.jsondrwxr-xr-x  4 1000 1000 4096 Mar 25 05:09 public-rw-r--r--  1 1000 1000  824 Mar 25 05:09 start.jsdrwxr-xr-x  2 1000 1000 4096 Mar 25 05:09 viewsEnvironment variablesBefore I install everything, I want to show you a cool thing call environment variables. These are variables that are accessible by your system, do list them just do:$ envHOSTNAME=7921e0543e40MONGODB_NAME=/focused_engelbart/mongodbMONGODB_PORT_27017_TCP=tcp://172.17.0.2:27017TERM=xtermMONGODB_PORT=tcp://172.17.0.2:27017MONGODB_PORT_27017_TCP_PORT=27017PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binPWD=/MONGODB_PORT_27017_TCP_PROTO=tcpSHLVL=1HOME=/MONGODB_PORT_27017_TCP_ADDR=172.17.0.2_=/usr/bin/envAs you can see, I have several variables that reference MongoDB, this is because of the link we created. If we take a look at our application we can see that we’re using those variables.var address = process.env.MONGODB_PORT_27017_TCP_ADDR;var port = process.env.MONGODB_PORT_27017_TCP_PORT;mongoose.connect(&quot;mongodb://&quot; + address + &quot;:&quot; + port + &quot;/blog&quot;);Now let’s install all dependencies:$ cd /var/www$ npm install ; expressjsmvc installNow, let’s just exit our container:$ exitAnd let’s run it again:$ docker run -itd -p 8000:3000 --name nodejs --link mongodb:mongodb -v /home/luis/Docker/blog-example:/var/www luis/nodejsNow, let’s see what’s going on inside the container with:$ docker logs nodejsAnd finally, let’s open the browser and go to http://localhost:8000You should see out application up and running. You can add a new blog post going to http://localhost:8000/blogs/addWhat about Varnish?This blog post already got too long, so that’s going to have to wait until the next post.",
    "url": "http://localhost:4000/2014-03-25/how-to-create-a-docker-node-js-mongodb-varnish-environment/"
  }
</script>
<!-- End Jekyll SEO tag -->


  <!-- Google Analytics -->

<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-39814139-1', 'auto');
ga('send', 'pageview');

</script>



</head>

<body>
  <div class="content-container">
    <header>
  <h1 class="header-small">
    <a href="http://localhost:4000">< BACK</a>
  </h1>
</header>
<div class="post">
  <h1 class="post-title">How to create a Docker + Node.js + MongoDB + Varnish environment</h1>
  <span class="post-date">
    <time>25 Mar 2014</time>
  </span>
  <div class="post-tag">
    <ul>
      
      <li>
        <a href="http://localhost:4000/tags#docker" class="tag">
          <span class="term">docker</span>
        </a>
      </li>
      
      
      <li>
        <a href="http://localhost:4000/tags#mongodb" class="tag">
          <span class="term">mongodb</span>
        </a>
      </li>
      
      
      <li>
        <a href="http://localhost:4000/tags#node-js" class="tag">
          <span class="term">node-js</span>
        </a>
      </li>
      
      
      <li>
        <a href="http://localhost:4000/tags#vagrant" class="tag">
          <span class="term">vagrant</span>
        </a>
      </li>
      
      
      <li>
        <a href="http://localhost:4000/tags#varnish" class="tag">
          <span class="term">varnish</span>
        </a>
      </li>
      
      
    </ul>
  </div>

  <p>I started learning <a href="https://www.docker.io/" target="_blank">Docker.io</a> over the weekend and I must say that it's really cool, unfortunatelly, this is still a new project and you don't find lots of documentation and tutorials online. At first, I struggled a little to do what I'm gonna show you, but here's the whole explanation so you don't have to. We're going to create a simple blog application written in Node.js running on a MongoDB database with a Varnish Load Balancer (covered on a different post) on top of the Node.js instances. We're going to use Docker and I strongly recommend to use Vagrant too, so you don't mess around too much with your host. In this tutorial, I won't cover installing Docker or the basics, since there's enough of that out there.</p>

<p>First we need to create a new directory, in this directory I'll download 3 Git projects:</p>

<ul>
<li><a target="_blank" href="https://github.com/luiselizondo/blog-example">A simple Blog application made with Node.js and Express.js MVC</a></li>
<li><a target="_blank" href="https://github.com/luiselizondo/docker-nodejs">The Docker Node.js image</a></li>
<li><a target="_blank" href="https://github.com/luiselizondo/docker-mongo">The Docker MongoDB image</a></li>
</ul>

<p>
After you download everything, you can take a look at the Dockerfiles, I'll explain a little what are they doing and how to run them.</p>

<h3>Node.js Docker image</h3>

<blockcode>
FROM ubuntu:12.04
MAINTAINER Luis Elizondo "lelizondo@gmail.com"
RUN echo "deb http://archive.ubuntu.com/ubuntu precise main universe" &gt; /etc/apt/sources.list
RUN apt-get updateRUN apt-get install -y python-software-properties curl git
RUN add-apt-repository -y ppa:chris-lea/node.js
RUN apt-get -qq update
RUN apt-get install -y nodejs
RUN npm install -g expressjsmvc express nodemon bower
EXPOSE 3000
ADD start.sh /start.sh
RUN chmod +x /start.sh
CMD ["/start.sh"]
</blockcode>

<p>This one has a Dockerfile, a README, a run.sh file and a start.sh file. The start.sh file is intended to be used <em>inside</em> the container so you won’t really be using it but it’s important that you don’t modify it unless you know what you’re doing.</p>

<p>The run.sh file is there so you can type ‘sh run.sh’ instead of the whole docker command which can get really long.</p>

<p>The Dockerfile will install nodejs, use npm to install expressjsmvc, express, bower and nodemon; and then it will expose the port 3000 before adding the ‘start.sh’ file to the container and then run it.</p>

<p>Now, I must explain something that I struggled with a little bit. When you’re using Dockerfiles (by now you should know what are they) you basically build your image so you can run containers and this container will run as specified. What this basically means is that you can create a container that will run a command as soon as it’s created <em>or</em> you can make this commands optional.</p>

<p>This is a huge difference and it really depends on the service you’re configuring. When you use the ENTRYPOINT property in your Dockerfile basically you’re telling the image to run that command as soon as the container is created, so if you do something like this:</p>

<p>Dockerfile:</p>

<p><code>
ENTRYPOINT ["/start.sh"]
</code></p>

<p>It means that the container will run the ‘start.sh’ file when it’s created. If you later want to do something like:</p>

<p><code>
$ docker run -it luis/nodejs bash
</code></p>

<p>To access the container, it will not work, since the container will just ignore everything and will run ‘start.sh’</p>

<p>So in order to have both, sometimes you’ll need to do CMD instead of ENTRYPOINT, this way, the container will run the command if you don’t pass any commands, but if you do pass any commands, it will run them.</p>

<p>If I replace my Dockerfile with</p>

<p><code>
CMD ["/start.sh"]
</code></p>

<p>Then</p>

<p><code>
$ docker run -it luis/nodejs bash
</code></p>

<p>Will run bash, and:</p>

<p><code>
$ docker run -it luis/nodejs
</code></p>

<p>Will run start.sh</p>

<h3>MongoDB Docker image</h3>
<p><code>
FROM ubuntu:12.04
MAINTAINER Luis Elizondo, lelizondo@gmail.com
RUN apt-get update</code></p>

<p>################## BEGIN INSTALLATION
####################### Install MongoDB Following the Instructions at MongoDB Docs</p>
<h1 id="ref-httpdocsmongodborgmanualtutorialinstall-mongodb-on-ubuntu">Ref: http://docs.mongodb.org/manual/tutorial/install-mongodb-on-ubuntu/</h1>

<h1 id="add-the-package-verification-key">Add the package verification key</h1>
<p>RUN apt-key adv –keyserver hkp://keyserver.ubuntu.com:80 –recv 7F0CEB10</p>

<h1 id="add-mongodb-to-the-repository-sources-list">Add MongoDB to the repository sources list</h1>
<p>RUN echo ‘deb http://downloads-distro.mongodb.org/repo/ubuntu-upstart dist 10gen’ | tee /etc/apt/sources.list.d/mongodb.list</p>

<h1 id="update-the-repository-sources-list-once-more">Update the repository sources list once more</h1>
<p>RUN apt-get update</p>

<h1 id="install-mongodb-package-deb">Install MongoDB package (.deb)</h1>
<p>RUN apt-get install -y mongodb-10gen</p>

<h1 id="create-the-default-data-directory">Create the default data directory</h1>
<p>RUN mkdir -p /data/db</p>

<p>##################### INSTALLATION END #####################</p>
<h1 id="expose-the-default-port">Expose the default port</h1>
<p>EXPOSE 27017</p>

<h1 id="default-port-to-execute-the-entrypoint-mongodb">Default port to execute the entrypoint (MongoDB)</h1>
<p>CMD [”–port 27017”]</p>

<h1 id="set-default-container-command">Set default container command</h1>
<p>ENTRYPOINT /usr/bin/mongod
&lt;/code&gt;</p>

<p>This one is easier, it will expose two ports and then run the mongod service using ENTRYPOINT, so you cannot really access the container unless you rewrite the entrypoint.</p>

<h3>Build the images</h3>
<p>The next step is to build your images, go to each directory containing a docker image and run:</p>

<p><code>
$ docker build -t myname/image-name .
</code></p>

<p>That command will build the image and tag it with a name, these are the commands I used:</p>

<p><code>
$ docker build -t luis/nodejs .
$ docker build -t luis/mongodb .
</code></p>

<p>If I want to list all my images, I just do:</p>

<p><code>
$ docker images</code></p>

<p>REPOSITORY          TAG                 IMAGE ID                      <br />
luis/nodejs         latest              3e9589892ef9               <br />
luis/mongodb        latest              79868a4506c7               <br />
&lt;/code&gt;</p>

<h3>How to link my docker containers?</h3>
<p>By now, you should be able to run your containers really easy and they should work, but they’re not linked, we need the Node container to access the MongoDB container. The first thing we need to do is to start a MongoDB container.</p>

<p><code>
$ docker run -itd -p 27017 --name mongodb luis/mongodb
</code></p>

<p>When we run this command, docker will create a new container with the image “luis/mongodb” and name that container as “mongodb”, it will also link the port 27017 to whatever port the container exposes, and it will also run this container as a daemon. This is very important since we want the container to start and keep running.</p>

<h3>Wait, what about files?</h3>
<p>Both MongoDB and your application need to read/write data on the HD, and you probably want to persist that data outside the container, which is disposable. The solution is to link volumes. First, let’s do this for MongoDB.</p>

<p>By default, MongoDB, inside the container, will save the data in /data/db, and that’s fine, we actually created that directory inside the container on the Dockerfile. MongoDB will think is saving the data in /data/db but in reality, it will be saving the data outside the container in a directory we specify.</p>

<p>Let’s create a new folder to save the data <em>outside</em> the container.</p>

<p><code>
$ sudo mkdir -p /var/mongodb
</code></p>

<p>And now, let’s fool MongoDB to save the data in /var/mongodb</p>

<p><code>
$ docker run -itd -p 27017 -v /var/mongodb:/data/db --name mongodb luis/mongodb
</code></p>

<p>What we’re doing differently is to link /var/mongodb (outside the container) to /data/db (inside the container).</p>

<p>The same principle will apply to your application files.</p>

<h3>Linking containers</h3>
<p>Now we can go back to linking our containers. First, make sure you clone the application, in my case, I’m using a Node.js application that I created earlier, my files are at /home/luis/Docker/blog-example</p>

<p>Now, to run my node.js container linked to MongoDB all I have to do is:</p>

<p><code>
$ docker run -itd -p 8000:3000 --name nodejs --link mongodb:mongodb -v /home/luis/Docker/blog-example:/var/www luis/nodejs
</code></p>

<p>Let’s explain what we’re doing with that command. First, we know my container will expose the port 3000, so we’re redirecting that port to the port 8000 (eventually we’ll have to modify this but for now we’re OK). Second, we set a name for the container. Third, we link the mongodb container, which basically allows the Node.js container to access the MongoDB container. Finally, we set the real path for /var/www, fooling our container for the real location of our files.</p>

<h3>My application is not working</h3>
<p>The application needs to install some stuff before running, so we’re going to need to install the dependencies before we run it.</p>

<p>Let’s kill the container first:</p>

<p><code>
$ docker rm -f nodejs
</code></p>

<p>And now, let’s bash into it:</p>

<p><code>
$ docker run -it -p 8000:3000 --link mongodb:mongodb -v /home/luis/Docker/blog-example:/var/www luis/nodejs bash
</code></p>

<p>Notice that we’re not daemonizing the container so we can actually access it.</p>

<p>If we list all the files in /var/www we’ll see that our application is there:</p>

<p><code>
$ ls -la /var/www
drwxr-xr-x  7 1000 1000 4096 Mar 25 05:09 .
drwxr-xr-x 20 root root 4096 Mar 25 05:20 ..
-rw-r--r--  1 1000 1000   34 Mar 25 05:09 .bowerrc
drwxr-xr-x  8 1000 1000 4096 Mar 25 05:09 .git
-rw-r--r--  1 1000 1000   44 Mar 25 05:09 .gitignore
-rw-r--r--  1 1000 1000 1377 Mar 25 05:09 app.js
-rw-r--r--  1 1000 1000  260 Mar 25 05:09 bower.json
drwxr-xr-x  4 1000 1000 4096 Mar 25 05:09 components
-rw-r--r--  1 1000 1000  169 Mar 25 05:09 expressjsmvc.json
drwxr-xr-x  2 1000 1000 4096 Mar 25 05:09 lib
-rw-r--r--  1 1000 1000  327 Mar 25 05:09 package.json
drwxr-xr-x  4 1000 1000 4096 Mar 25 05:09 public
-rw-r--r--  1 1000 1000  824 Mar 25 05:09 start.js
drwxr-xr-x  2 1000 1000 4096 Mar 25 05:09 views
</code></p>

<h3>Environment variables</h3>
<p>Before I install everything, I want to show you a cool thing call environment variables. These are variables that are accessible by your system, do list them just do:</p>

<p><code>
$ env
HOSTNAME=7921e0543e40
MONGODB_NAME=/focused_engelbart/mongodb
MONGODB_PORT_27017_TCP=tcp://172.17.0.2:27017
TERM=xterm
MONGODB_PORT=tcp://172.17.0.2:27017
MONGODB_PORT_27017_TCP_PORT=27017
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
PWD=/
MONGODB_PORT_27017_TCP_PROTO=tcp
SHLVL=1
HOME=/
MONGODB_PORT_27017_TCP_ADDR=172.17.0.2
_=/usr/bin/env
</code></p>

<p>As you can see, I have several variables that reference MongoDB, this is because of the link we created. If we take a look at our application we can see that we’re using those variables.</p>

<p><code>
var address = process.env.MONGODB_PORT_27017_TCP_ADDR;
var port = process.env.MONGODB_PORT_27017_TCP_PORT;
mongoose.connect("mongodb://" + address + ":" + port + "/blog");
</code></p>

<p>Now let’s install all dependencies:</p>

<p><code>
$ cd /var/www
$ npm install ; expressjsmvc install
</code></p>

<p>Now, let’s just exit our container:</p>

<p><code>
$ exit
</code></p>

<p>And let’s run it again:</p>

<p><code>
$ docker run -itd -p 8000:3000 --name nodejs --link mongodb:mongodb -v /home/luis/Docker/blog-example:/var/www luis/nodejs
</code></p>

<p>Now, let’s see what’s going on inside the container with:</p>

<p><code>
$ docker logs nodejs
</code></p>

<p>And finally, let’s open the browser and go to http://localhost:8000</p>

<p>You should see out application up and running. You can add a new blog post going to http://localhost:8000/blogs/add</p>

<h3>What about Varnish?</h3>
<p>This blog post already got too long, so that’s going to have to wait until the next post.</p>



  <!-- Share -->
  
  <div class="post-share">
    <hr>
    <span>Share this: <br /></span>
<a href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/2014-03-25/how-to-create-a-docker-node-js-mongodb-varnish-environment/" onclick="window.open(this.href, 'mywin',
'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" class="ssk ssk-icon ssk-facebook"></a>
<a href="https://twitter.com/intent/tweet?text=How to create a Docker + Node.js + MongoDB + Varnish environment&url=http://localhost:4000/2014-03-25/how-to-create-a-docker-node-js-mongodb-varnish-environment/" onclick="window.open(this.href, 'mywin',
'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" class="ssk ssk-icon ssk-twitter"></a>
<a href="https://plus.google.com/share?url=http://localhost:4000/2014-03-25/how-to-create-a-docker-node-js-mongodb-varnish-environment/" onclick="window.open(this.href, 'mywin',
'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" class="ssk ssk-icon ssk-google-plus"></a>
<a href="https://www.tumblr.com/share?url=http://localhost:4000/2014-03-25/how-to-create-a-docker-node-js-mongodb-varnish-environment/" onclick="window.open(this.href, 'mywin',
'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" class="ssk ssk-icon ssk-tumblr"></a>
<a href="mailto:?subject=How to create a Docker + Node.js + MongoDB + Varnish environment&amp;body=Check out this site http://localhost:4000/2014-03-25/how-to-create-a-docker-node-js-mongodb-varnish-environment/" class="ssk ssk-icon ssk-email"></a>

    <hr>
  </div>
  

  <!-- Disqus -->
  
  <section id="disqus_thread"></section>
  <script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = '//luiselizondobaez.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  

</div>


    <!-- Documents about icons are here: http://fontawesome.io/icons/ -->
<div class="footer">
	<hr />
	<div class="footer-link">
		

		
		<a href="https://twitter.com/lelizondo"><i class="fa fa-twitter" aria-hidden="true"></i></a>
		

		
		<a href="https://github.com/luiselizondo"><i class="fa fa-github" aria-hidden="true"></i></a>
		

		
		<a href="https://www.linkedin.com/in/luiselizondobaez"><i class="fa fa-linkedin" aria-hidden="true"></i></a>
		

		

		

		

	</div>
	© 2016 Luis Elizondo. All rights reserved.
</div>

  </div>
</body>
</html>
